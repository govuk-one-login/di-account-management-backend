"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-empty-interface */
const assert_1 = tslib_1.__importDefault(require("assert"));
/**
 * Prettyprints command calls for message
 */
const printCalls = (ctx, calls) => calls.length > 0
    ? [
        '',
        'Calls:',
        ...calls.map((c, i) => `  ${i + 1}. ${c.args[0].constructor.name}: ${ctx.utils.printReceived(c.args[0].input)}`)
    ]
    : [];
const processMatch = ({ ctx, mockClient, command, check, message }) => {
    (0, assert_1.default)(command &&
        typeof command === 'function' &&
        typeof command.name === 'string' &&
        command.name.length > 0, 'Command must be valid AWS SDK Command');
    const calls = mockClient.calls();
    const commandCalls = mockClient.commandCalls(command);
    const { pass, data } = check({ calls, commandCalls });
    const msg = () => {
        const cmd = ctx.utils.printExpected(command.name);
        const client = mockClient.clientName();
        return [
            ...message({
                client,
                cmd,
                data,
                commandCalls,
                notPrefix: ctx.isNot ? 'not ' : '',
            }),
            ...printCalls(ctx, calls),
        ].join('\n');
    };
    return { pass, message: msg };
};
const baseMatchers = {
    /**
     * implementation of {@link AwsSdkJestMockMatchers.toHaveReceivedCommand} matcher
     */
    toHaveReceivedCommand(mockClient, command) {
        return processMatch({
            ctx: this,
            mockClient,
            command,
            check: ({ commandCalls }) => ({ pass: commandCalls.length > 0, data: undefined }),
            message: ({ client, cmd, notPrefix, commandCalls }) => [
                `Expected ${client} to ${notPrefix}receive ${cmd}`,
                `${client} received ${cmd} ${this.utils.printReceived(commandCalls.length)} times`,
            ],
        });
    },
    /**
     * implementation of {@link AwsSdkJestMockMatchers.toHaveReceivedCommandTimes} matcher
     */
    toHaveReceivedCommandTimes(mockClient, command, expectedCalls) {
        return processMatch({
            ctx: this,
            mockClient,
            command,
            check: ({ commandCalls }) => ({ pass: commandCalls.length === expectedCalls, data: undefined }),
            message: ({ client, cmd, commandCalls, notPrefix }) => [
                `Expected ${client} to ${notPrefix}receive ${cmd} ${this.utils.printExpected(expectedCalls)} times`,
                `${client} received ${cmd} ${this.utils.printReceived(commandCalls.length)} times`,
            ],
        });
    },
    /**
     * implementation of {@link AwsSdkJestMockMatchers.toHaveReceivedCommandWith} matcher
     */
    toHaveReceivedCommandWith(mockClient, command, input) {
        return processMatch({
            ctx: this,
            mockClient,
            command,
            check: ({ commandCalls }) => {
                const matchCount = commandCalls
                    .map(call => call.args[0].input) // eslint-disable-line @typescript-eslint/no-unsafe-return
                    .map(received => {
                    try {
                        expect(received).toEqual(expect.objectContaining(input));
                        return true;
                    }
                    catch (e) {
                        return false;
                    }
                })
                    .reduce((acc, val) => acc + Number(val), 0);
                return { pass: matchCount > 0, data: { matchCount } };
            },
            message: ({ client, cmd, notPrefix, data }) => [
                `Expected ${client} to ${notPrefix}receive ${cmd} with ${this.utils.printExpected(input)}`,
                `${client} received matching ${cmd} ${this.utils.printReceived(data.matchCount)} times`,
            ],
        });
    },
    /**
     * implementation of {@link AwsSdkJestMockMatchers.toHaveReceivedNthCommandWith} matcher
     */
    toHaveReceivedNthCommandWith(mockClient, call, command, input) {
        (0, assert_1.default)(call && typeof call === 'number' && call > 0, 'Call number must be a number greater than 0');
        return processMatch({
            ctx: this,
            mockClient,
            command,
            check: ({ calls }) => {
                if (calls.length < call) {
                    return { pass: false, data: { received: undefined } };
                }
                const received = calls[call - 1].args[0];
                let pass = false;
                if (received instanceof command) {
                    try {
                        expect(received.input).toEqual(expect.objectContaining(input));
                        pass = true;
                    }
                    catch (e) { // eslint-disable-line no-empty
                    }
                }
                return {
                    pass,
                    data: { received },
                };
            },
            message: ({ cmd, client, data, notPrefix }) => [
                `Expected ${client} to ${notPrefix}receive ${call}. ${cmd} with ${this.utils.printExpected(input)}`,
                ...(data.received
                    ? [
                        `${client} received ${this.utils.printReceived(data.received.constructor.name)} with input:`,
                        this.utils.printDiffOrStringify(input, data.received.input, 'Expected', 'Received', false),
                    ]
                    : []),
            ],
        });
    },
};
/* typing ensures keys matching */
const aliasMatchers = {
    toReceiveCommandTimes: baseMatchers.toHaveReceivedCommandTimes,
    toReceiveCommand: baseMatchers.toHaveReceivedCommand,
    toReceiveCommandWith: baseMatchers.toHaveReceivedCommandWith,
    toReceiveNthCommandWith: baseMatchers.toHaveReceivedNthCommandWith,
};
// Skip registration if jest expect does not exist
if (typeof expect !== 'undefined' && typeof expect.extend === 'function') {
    expect.extend({ ...baseMatchers, ...aliasMatchers });
}
//# sourceMappingURL=jestMatchers.js.map