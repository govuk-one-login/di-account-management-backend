import { MixedBackendCryptoKey, SupportedAlgorithmSuites, AwsEsdkJsCryptoKey, AwsEsdkJsKeyUsage, EncryptionContext, AwsEsdkKeyObject, AwsEsdkCreateSecretKey } from './types';
import { EncryptedDataKey } from './encrypted_data_key';
import { SignatureKey, VerificationKey } from './signature_key';
import { KeyringTrace, KeyringTraceFlag } from './keyring_trace';
import { NodeAlgorithmSuite } from './node_algorithms';
import { WebCryptoAlgorithmSuite } from './web_crypto_algorithms';
interface AwsEsdkKeyObjectInstanceOf {
    new (): AwsEsdkKeyObject;
}
export declare const supportsKeyObject: boolean | {
    KeyObject: AwsEsdkKeyObjectInstanceOf;
    createSecretKey: AwsEsdkCreateSecretKey;
};
export interface FunctionalCryptographicMaterial {
    hasValidKey: () => boolean;
}
export interface CryptographicMaterial<T extends CryptographicMaterial<T>> {
    suite: SupportedAlgorithmSuites;
    setUnencryptedDataKey: (dataKey: Uint8Array | AwsEsdkKeyObject, trace: KeyringTrace) => T;
    getUnencryptedDataKey: () => Uint8Array | AwsEsdkKeyObject;
    zeroUnencryptedDataKey: () => T;
    hasUnencryptedDataKey: boolean;
    keyringTrace: KeyringTrace[];
    encryptionContext: Readonly<EncryptionContext>;
}
export interface EncryptionMaterial<T extends CryptographicMaterial<T>> extends CryptographicMaterial<T> {
    encryptedDataKeys: EncryptedDataKey[];
    addEncryptedDataKey: (edk: EncryptedDataKey, flags: KeyringTraceFlag) => T;
    setSignatureKey: (key: SignatureKey) => T;
    signatureKey?: SignatureKey;
}
export interface DecryptionMaterial<T extends CryptographicMaterial<T>> extends CryptographicMaterial<T> {
    setVerificationKey: (key: VerificationKey) => T;
    verificationKey?: VerificationKey;
}
export interface WebCryptoMaterial<T extends CryptographicMaterial<T>> extends CryptographicMaterial<T> {
    setCryptoKey: (dataKey: AwsEsdkJsCryptoKey | MixedBackendCryptoKey, trace: KeyringTrace) => T;
    getCryptoKey: () => AwsEsdkJsCryptoKey | MixedBackendCryptoKey;
    hasCryptoKey: boolean;
    validUsages: ReadonlyArray<AwsEsdkJsKeyUsage>;
}
export declare class NodeEncryptionMaterial implements Readonly<EncryptionMaterial<NodeEncryptionMaterial>>, FunctionalCryptographicMaterial {
    suite: NodeAlgorithmSuite;
    setUnencryptedDataKey: (dataKey: Uint8Array | AwsEsdkKeyObject, trace: KeyringTrace) => NodeEncryptionMaterial;
    getUnencryptedDataKey: () => Uint8Array | AwsEsdkKeyObject;
    zeroUnencryptedDataKey: () => NodeEncryptionMaterial;
    hasUnencryptedDataKey: boolean;
    keyringTrace: KeyringTrace[];
    encryptedDataKeys: EncryptedDataKey[];
    addEncryptedDataKey: (edk: EncryptedDataKey, flags: KeyringTraceFlag) => NodeEncryptionMaterial;
    setSignatureKey: (key: SignatureKey) => NodeEncryptionMaterial;
    signatureKey?: SignatureKey;
    encryptionContext: Readonly<EncryptionContext>;
    constructor(suite: NodeAlgorithmSuite, encryptionContext: EncryptionContext);
    hasValidKey(): boolean;
}
export declare class NodeDecryptionMaterial implements Readonly<DecryptionMaterial<NodeDecryptionMaterial>>, FunctionalCryptographicMaterial {
    suite: NodeAlgorithmSuite;
    setUnencryptedDataKey: (dataKey: Uint8Array | AwsEsdkKeyObject, trace: KeyringTrace) => NodeDecryptionMaterial;
    getUnencryptedDataKey: () => Uint8Array | AwsEsdkKeyObject;
    zeroUnencryptedDataKey: () => NodeDecryptionMaterial;
    hasUnencryptedDataKey: boolean;
    keyringTrace: KeyringTrace[];
    setVerificationKey: (key: VerificationKey) => NodeDecryptionMaterial;
    verificationKey?: VerificationKey;
    encryptionContext: Readonly<EncryptionContext>;
    constructor(suite: NodeAlgorithmSuite, encryptionContext: EncryptionContext);
    hasValidKey(): boolean;
}
export declare class WebCryptoEncryptionMaterial implements Readonly<EncryptionMaterial<WebCryptoEncryptionMaterial>>, Readonly<WebCryptoMaterial<WebCryptoEncryptionMaterial>>, FunctionalCryptographicMaterial {
    suite: WebCryptoAlgorithmSuite;
    setUnencryptedDataKey: (dataKey: Uint8Array | AwsEsdkKeyObject, trace: KeyringTrace) => WebCryptoEncryptionMaterial;
    getUnencryptedDataKey: () => Uint8Array | AwsEsdkKeyObject;
    zeroUnencryptedDataKey: () => WebCryptoEncryptionMaterial;
    hasUnencryptedDataKey: boolean;
    keyringTrace: KeyringTrace[];
    encryptedDataKeys: EncryptedDataKey[];
    addEncryptedDataKey: (edk: EncryptedDataKey, flags: KeyringTraceFlag) => WebCryptoEncryptionMaterial;
    setSignatureKey: (key: SignatureKey) => WebCryptoEncryptionMaterial;
    signatureKey?: SignatureKey;
    setCryptoKey: (dataKey: AwsEsdkJsCryptoKey | MixedBackendCryptoKey, trace: KeyringTrace) => WebCryptoEncryptionMaterial;
    getCryptoKey: () => AwsEsdkJsCryptoKey | MixedBackendCryptoKey;
    hasCryptoKey: boolean;
    validUsages: ReadonlyArray<AwsEsdkJsKeyUsage>;
    encryptionContext: Readonly<EncryptionContext>;
    constructor(suite: WebCryptoAlgorithmSuite, encryptionContext: EncryptionContext);
    hasValidKey(): boolean;
}
export declare class WebCryptoDecryptionMaterial implements Readonly<DecryptionMaterial<WebCryptoDecryptionMaterial>>, Readonly<WebCryptoMaterial<WebCryptoDecryptionMaterial>>, FunctionalCryptographicMaterial {
    suite: WebCryptoAlgorithmSuite;
    setUnencryptedDataKey: (dataKey: Uint8Array | AwsEsdkKeyObject, trace: KeyringTrace) => WebCryptoDecryptionMaterial;
    getUnencryptedDataKey: () => Uint8Array | AwsEsdkKeyObject;
    zeroUnencryptedDataKey: () => WebCryptoDecryptionMaterial;
    hasUnencryptedDataKey: boolean;
    keyringTrace: KeyringTrace[];
    setVerificationKey: (key: VerificationKey) => WebCryptoDecryptionMaterial;
    verificationKey?: VerificationKey;
    setCryptoKey: (dataKey: AwsEsdkJsCryptoKey | MixedBackendCryptoKey, trace: KeyringTrace) => WebCryptoDecryptionMaterial;
    getCryptoKey: () => AwsEsdkJsCryptoKey | MixedBackendCryptoKey;
    hasCryptoKey: boolean;
    validUsages: ReadonlyArray<AwsEsdkJsKeyUsage>;
    encryptionContext: Readonly<EncryptionContext>;
    constructor(suite: WebCryptoAlgorithmSuite, encryptionContext: EncryptionContext);
    hasValidKey(): boolean;
}
export declare function isEncryptionMaterial(obj: any): obj is WebCryptoEncryptionMaterial | NodeEncryptionMaterial;
export declare function isDecryptionMaterial(obj: any): obj is WebCryptoDecryptionMaterial | NodeDecryptionMaterial;
export declare function decorateCryptographicMaterial<T extends CryptographicMaterial<T>>(material: T, setFlag: KeyringTraceFlag): T;
export declare function decorateEncryptionMaterial<T extends EncryptionMaterial<T>>(material: T): T;
export declare function decorateDecryptionMaterial<T extends DecryptionMaterial<T>>(material: T): T;
export declare function decorateWebCryptoMaterial<T extends WebCryptoMaterial<T>>(material: T, setFlags: KeyringTraceFlag): T;
export declare function isCryptoKey(dataKey: any): dataKey is AwsEsdkJsCryptoKey;
export declare function isValidCryptoKey<T extends WebCryptoMaterial<T>>(dataKey: AwsEsdkJsCryptoKey | MixedBackendCryptoKey, material: T): boolean;
export declare function keyUsageForMaterial<T extends WebCryptoMaterial<T>>(material: T): AwsEsdkJsKeyUsage;
export declare function subtleFunctionForMaterial<T extends WebCryptoMaterial<T>>(material: T): "encrypt" | "decrypt";
export declare function unwrapDataKey(dataKey: Uint8Array | AwsEsdkKeyObject): Uint8Array;
export declare function wrapWithKeyObjectIfSupported(dataKey: Uint8Array | AwsEsdkKeyObject): Uint8Array | AwsEsdkKeyObject;
export {};
//# sourceMappingURL=cryptographic_material.d.ts.map