"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseProvider = void 0;
const commons_1 = require("@aws-lambda-powertools/commons");
const GetOptions_1 = require("./GetOptions");
const GetMultipleOptions_1 = require("./GetMultipleOptions");
const ExpirableValue_1 = require("./ExpirableValue");
const errors_1 = require("../errors");
const EnvironmentVariablesService_1 = require("../config/EnvironmentVariablesService");
const transformValue_1 = require("./transformValue");
/**
 * Base class for all providers.
 *
 * As an abstract class, it should not be used directly, but rather extended by other providers.
 *
 * It implements the common logic for all providers, such as caching, transformation, etc.
 * Each provider that extends this class must implement the `_get` and `_getMultiple` abstract methods.
 *
 * These methods are responsible for retrieving the values from the underlying parameter store. They are
 * called by the `get` and `getMultiple` methods, which are responsible for caching and transformation.
 *
 * If there are multiple calls to the same parameter but in a different transform, they will be stored multiple times.
 * This allows us to optimize by transforming the data only once per retrieval, thus there is no need to transform cached values multiple times.
 *
 * However, this means that we need to make multiple calls to the underlying parameter store if we need to return it in different transforms.
 *
 * Since the number of supported transform is small and the probability that a given parameter will always be used in a specific transform,
 * this should be an acceptable tradeoff.
 */
class BaseProvider {
    constructor() {
        this.store = new Map();
        this.envVarsService = new EnvironmentVariablesService_1.EnvironmentVariablesService();
    }
    /**
     * Add a value to the cache.
     *
     * @param {string} key - Key of the cached value
     * @param {string | Uint8Array | Record<string, unknown>} value - Value to be cached
     * @param {number} maxAge - Maximum age in seconds for the value to be cached
     */
    addToCache(key, value, maxAge) {
        if (maxAge <= 0)
            return;
        this.store.set(key, new ExpirableValue_1.ExpirableValue(value, maxAge));
    }
    /**
     * Clear the cache.
     */
    clearCache() {
        this.store.clear();
    }
    /**
     * Retrieve a parameter value or return the cached value.
     *
     * @param {string} name - Parameter name
     * @param {GetOptionsInterface} options - Options to configure maximum age, trasformation, AWS SDK options, or force fetch
     */
    async get(name, options) {
        const configs = new GetOptions_1.GetOptions(options, this.envVarsService);
        const key = [name, configs.transform].toString();
        if (!configs.forceFetch && !this.hasKeyExpiredInCache(key)) {
            return this.store.get(key)?.value;
        }
        try {
            let value = await this._get(name, options);
            if ((0, commons_1.isNullOrUndefined)(value))
                return undefined;
            if (configs.transform &&
                ((0, commons_1.isString)(value) || value instanceof Uint8Array)) {
                value = (0, transformValue_1.transformValue)(value, configs.transform, true, name);
            }
            this.addToCache(key, value, configs.maxAge);
            return value;
        }
        catch (error) {
            if (error instanceof errors_1.TransformParameterError)
                throw error;
            throw new errors_1.GetParameterError(error.message);
        }
    }
    /**
     * Retrieve multiple parameter values or return the cached values.
     *
     * @param {string} path - Parameters path
     * @param {GetMultipleOptionsInterface} options - Options to configure maximum age, trasformation, AWS SDK options, or force fetch
     * @returns
     */
    async getMultiple(path, options) {
        const configs = new GetMultipleOptions_1.GetMultipleOptions(options, this.envVarsService);
        const key = [path, configs.transform].toString();
        if (!configs.forceFetch && !this.hasKeyExpiredInCache(key)) {
            // If the code enters in this block, then the key must exist & not have been expired
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.store.get(key).value;
        }
        let values;
        try {
            values = await this._getMultiple(path, options);
            if (!(0, commons_1.isRecord)(values)) {
                throw new errors_1.GetParameterError(`Expected result to be a Record<string, unknown> but got ${typeof values}`);
            }
        }
        catch (error) {
            throw new errors_1.GetParameterError(error.message);
        }
        if (configs.transform) {
            for (const [entryKey, entryValue] of Object.entries(values)) {
                if (!((0, commons_1.isString)(entryValue) || entryValue instanceof Uint8Array))
                    continue;
                try {
                    values[entryKey] = (0, transformValue_1.transformValue)(entryValue, configs.transform, configs.throwOnTransformError, entryKey);
                }
                catch (error) {
                    if (configs.throwOnTransformError)
                        throw new errors_1.TransformParameterError(configs.transform, error.message);
                }
            }
        }
        if (Object.keys(values).length !== 0) {
            this.addToCache(key, values, configs.maxAge);
        }
        return values;
    }
    /**
     * Check whether a key has expired in the cache or not.
     *
     * It returns true if the key is expired or not present in the cache.
     *
     * @param {string} key - Stringified representation of the key to retrieve
     */
    hasKeyExpiredInCache(key) {
        const value = this.store.get(key);
        if (value)
            return value.isExpired();
        return true;
    }
}
exports.BaseProvider = BaseProvider;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFzZVByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Jhc2UvQmFzZVByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDREQUl3QztBQUN4Qyw2Q0FBMEM7QUFDMUMsNkRBQTBEO0FBQzFELHFEQUFrRDtBQUNsRCxzQ0FBdUU7QUFDdkUsdUZBQW9GO0FBQ3BGLHFEQUFrRDtBQU9sRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JHO0FBQ0gsTUFBZSxZQUFZO0lBSXpCO1FBQ0UsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSx5REFBMkIsRUFBRSxDQUFDO0lBQzFELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxVQUFVLENBQUMsR0FBVyxFQUFFLEtBQWMsRUFBRSxNQUFjO1FBQzNELElBQUksTUFBTSxJQUFJLENBQUM7WUFBRSxPQUFPO1FBRXhCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLCtCQUFjLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksVUFBVTtRQUNmLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksS0FBSyxDQUFDLEdBQUcsQ0FDZCxJQUFZLEVBQ1osT0FBNkI7UUFFN0IsTUFBTSxPQUFPLEdBQUcsSUFBSSx1QkFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDN0QsTUFBTSxHQUFHLEdBQUcsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRWpELElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFD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