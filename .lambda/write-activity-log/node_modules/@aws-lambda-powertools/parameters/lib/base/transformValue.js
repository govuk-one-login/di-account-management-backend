"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformValue = void 0;
const commons_1 = require("@aws-lambda-powertools/commons");
const util_base64_node_1 = require("@aws-sdk/util-base64-node");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
/**
 * Utility function to transform a value.
 *
 * It supports JSON and binary transformations, as well as an `auto` mode that will try to transform the value based on the key.
 *
 * The function supports both `string` and `Uint8Array` values as input. Other types will be returned as-is.
 *
 * If the value is a `Uint8Array`, it will be decoded to a string first. Then, when the transform is `json` or `auto` and the key ends with `.json`,
 * the value will be parsed as JSON using the `JSON.parse` function.
 *
 * When the transform is `binary` or `auto` and the key ends with `.binary`, the value will be decoded from base64 using the `fromBase64` function
 * from the `@aws-sdk/util-base64-node` package.
 *
 * If the transformation fails, the function will return the value as-is unless `throwOnTransformError` is set to `true`.
 *
 * @note When using `auto` mode, the key must end with either `.json` or `.binary` to be transformed. Automatic transformation is supported only for
 * `getMultiple` calls.
 *
 * @param {string | Uint8Array} value - Value to be transformed
 * @param {TransformOptions} transform - Transform to be applied, can be `json`, `binary`, or `auto`
 * @param {boolean} throwOnTransformError - Whether to throw an error if the transformation fails, when transforming multiple values this can be set to false
 * @param {string} key - Key of the value to be transformed, used to determine the transformation method when using 'auto'
 */
const transformValue = (value, transform, throwOnTransformError, key) => {
    const normalizedTransform = transform.toLowerCase();
    const isAutoTransform = normalizedTransform === 'auto';
    const isAutoJsonTransform = isAutoTransform && key.toLowerCase().endsWith(`.${constants_1.TRANSFORM_METHOD_JSON}`);
    const isAutoBinaryTransform = isAutoTransform &&
        key.toLowerCase().endsWith(`.${constants_1.TRANSFORM_METHOD_BINARY}`);
    const isJsonTransform = normalizedTransform === constants_1.TRANSFORM_METHOD_JSON;
    const isBinaryTransform = normalizedTransform === constants_1.TRANSFORM_METHOD_BINARY;
    // If the value is not a string or Uint8Array, or if the transform is `auto`
    // and the key does not end with `.json` or `.binary`, return the value as-is
    if (!(value instanceof Uint8Array || (0, commons_1.isString)(value)) ||
        (isAutoTransform && !isAutoJsonTransform && !isAutoBinaryTransform)) {
        return value;
    }
    try {
        // If the value is a Uint8Array, decode it to a string first
        if (value instanceof Uint8Array) {
            value = new TextDecoder('utf-8').decode(value);
        }
        // If the transform is `json` or `auto` and the key ends with `.json`, parse the value as JSON
        if (isJsonTransform || isAutoJsonTransform) {
            return JSON.parse(value);
            // If the transform is `binary` or `auto` and the key ends with `.binary`, decode the value from base64
        }
        else if (isBinaryTransform || isAutoBinaryTransform) {
            return new TextDecoder('utf-8').decode((0, util_base64_node_1.fromBase64)(value));
        }
    }
    catch (error) {
        if (throwOnTransformError)
            throw new errors_1.TransformParameterError(transform, error.message);
        return;
    }
};
exports.transformValue = transformValue;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmb3JtVmFsdWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYmFzZS90cmFuc2Zvcm1WYWx1ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSw0REFBMEQ7QUFDMUQsZ0VBQXVEO0FBQ3ZELDRDQUE4RTtBQUM5RSxzQ0FBb0Q7QUFHcEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQkc7QUFDSCxNQUFNLGNBQWMsR0FBRyxDQUNyQixLQUEwQixFQUMxQixTQUEyQixFQUMzQixxQkFBOEIsRUFDOUIsR0FBVyxFQUNrQyxFQUFFO0lBQy9DLE1BQU0sbUJBQW1CLEdBQUcsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3BELE1BQU0sZUFBZSxHQUFHLG1CQUFtQixLQUFLLE1BQU0sQ0FBQztJQUN2RCxNQUFNLG1CQUFtQixHQUN2QixlQUFlLElBQUksR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLGlDQUFxQixFQUFFLENBQUMsQ0FBQztJQUM3RSxNQUFNLHFCQUFxQixHQUN6QixlQUFlO1FBQ2YsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLG1DQUF1QixFQUFFLENBQUMsQ0FBQztJQUM1RCxNQUFNLGVBQWUsR0FBRyxtQkFBbUIsS0FBSyxpQ0FBcUIsQ0FBQztJQUN0RSxNQUFNLGlCQUFpQixHQUFHLG1CQUFtQixLQUFLLG1DQUF1QixDQUFDO0lBRTFFLDRFQUE0RTtJQUM1RSw2RUFBNkU7SUFDN0UsSUFDRSxDQUFDLENBQUMsS0FBSyxZQUFZLFVBQVUsSUFBSSxJQUFBLGtCQUFRLEVBQUMsS0FBSyxDQUFDLENBQUM7UUFDakQsQ0FBQyxlQUFlLElBQUksQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEVBQ25FO1FBQ0EsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELElBQUk7UUFDRiw0REFBNEQ7UUFDNUQsSUFBSSxLQUFLLFlBQVksVUFBVSxFQUFFO1lBQy9CLEtBQUssR0FBRyxJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDaEQ7UUFFRCw4RkFBOEY7UUFDOUYsSUFBSSxlQUFlLElBQUksbUJBQW1CLEVBQUU7WUFDMUMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBYyxDQUFDO1lBQ3RDLHVHQUF1RztTQUN4RzthQUFNLElBQUksaUJBQWlCLElBQUkscUJBQXFCLEVBQUU7WUFDckQsT0FBTyxJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBQSw2QkFBVSxFQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDM0Q7S0FDRjtJQUFDLE9BQU8sS0FBSyxFQUFFO1FBQ2QsSUFBSSxxQkFBcUI7WUFDdkIsTUFBTSxJQUFJLGdDQUF1QixDQUFDLFNBQVMsRUFBRyxLQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFekUsT0FBTztLQUNSO0FBQ0gsQ0FBQyxDQUFDO0FBRU8sd0NBQWMifQ==