"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_PROVIDERS = exports.SSMProvider = void 0;
const base_1 = require("../base");
Object.defineProperty(exports, "DEFAULT_PROVIDERS", { enumerable: true, get: function () { return base_1.DEFAULT_PROVIDERS; } });
const transformValue_1 = require("../base/transformValue");
const errors_1 = require("../errors");
const constants_1 = require("../constants");
const client_ssm_1 = require("@aws-sdk/client-ssm");
const commons_1 = require("@aws-lambda-powertools/commons");
/**
 * ## Intro
 * The Parameters utility provides a SSMProvider that allows to retrieve parameters from AWS Systems Manager.
 *
 * ## Getting started
 *
 * This utility supports AWS SDK v3 for JavaScript only. This allows the utility to be modular, and you to install only
 * the SDK packages you need and keep your bundle size small.
 *
 * To use the provider, you must install the Parameters utility and the AWS SDK v3 for JavaScript for AppConfig:
 *
 * ```sh
 * npm install @aws-lambda-powertools/parameters @aws-sdk/client-ssm
 * ```
 *
 * ## Basic usage
 *
 * Retrieve a parameter from SSM:
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider();
 *
 * export const handler = async (): Promise<void> => {
 *   // Retrieve a parameter from SSM
 *   const parameter = await parametersProvider.get('/my-parameter');
 * };
 * ```
 *
 * If you want to retrieve a parameter without customizing the provider, you can use the {@link getParameter} function instead.
 *
 * You can also retrieve parameters at once. If you want to get multiple parameters under the same path, you can use the `getMultiple` method.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider();
 *
 * export const handler = async (): Promise<void> => {
 *  // Retrieve multiple parameters by path from SSM
 *  const parameters = await parametersProvider.getMultiple('/my-parameters-path');
 * };
 * ```
 *
 * If you don't need to customize the provider, you can also use the {@link getParameters} function instead.
 *
 * If instead you want to retrieve multiple parameters by name, you can use the `getParametersByName` method.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider();
 *
 * export const handler = async (): Promise<void> => {
 *   // Retrieve multiple parameters by name from SSM
 *   const parameters = await parametersProvider.getParametersByName({
 *     '/my-parameter-1': {}, // Use default options
 *     '/my-parameter-2': { transform: 'json' }, // Parse the value as JSON
 *   });
 * };
 * ```
 *
 * If you don't need to customize the provider, you can also use the {@link getParametersByName} function instead.
 *
 * ## Advanced usage
 *
 * ### Caching
 *
 * By default, the provider will cache parameters retrieved in-memory for 5 seconds.
 * You can adjust how long values should be kept in cache by using the `maxAge` parameter.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider();
 *
 * export const handler = async (): Promise<void> => {
 *   // Retrieve a parameter and cache it for 10 seconds
 *   const parameter = await parametersProvider.get('/my-parameter', { maxAge: 10 });
 *   // Retrieve multiple parameters by path and cache them for 20 seconds
 *   const parameters = await parametersProvider.getMultiple('/my-parameters-path', { maxAge: 20 });
 * };
 * ```
 *
 * When using the `getParametersByName` method, you can set a different `maxAge` for each parameter or set a default `maxAge` for all parameters.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider();
 *
 * export const handler = async (): Promise<void> => {
 *   // Retrieve multiple parameters by name and cache them individually
 *   const parameters = await parametersProvider.getParametersByName({
 *     '/my-parameter-1': { maxAge: 10 }, // Cache for 10 seconds
 *     '/my-parameter-2': { maxAge: 20 }, // Cache for 20 seconds
 *   });
 *   // Retrieve multiple parameters by name and cache them all for 20 seconds
 *   const parameters = await parametersProvider.getParametersByName({
 *     '/my-parameter-1': {},
 *     '/my-parameter-2': {},
 *   }, { maxAge: 20 });
 * };
 * ```
 *
 * If instead you'd like to always ensure you fetch the latest parameter from the store regardless if already available in cache, use the `forceFetch` parameter.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider();
 *
 * export const handler = async (): Promise<void> => {
 *   // Retrieve a parameter and skip cache
 *   const parameter = await parametersProvider.get('/my-parameter', { forceFetch: true });
 *   // Retrieve multiple parameters and skip cache
 *   const parameters = await parametersProvider.getMultiple('/my-parameters-path', { forceFetch: true });
 * };
 * ```
 *
 * Likewise, you can use the `forceFetch` parameter with the `getParametersByName` method both for individual parameters and for all parameters.
 *
 * ### Decryption
 *
 * If you want to retrieve a parameter that is encrypted, you can use the `decrypt` parameter. This parameter is compatible with `get`, `getMultiple` and `getParametersByName`.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider();
 *
 * export const handler = async (): Promise<void> => {
 *   // Retrieve a parameter and decrypt it
 *   const parameter = await parametersProvider.get('/my-parameter', { decrypt: true });
 *   // Retrieve multiple parameters and decrypt them
 *   const parameters = await parametersProvider.getMultiple('/my-parameters-path', { decrypt: true });
 * };
 * ```
 *
 * ### Transformations
 *
 * For parameters stored as JSON you can use the transform argument for deserialization. This will return a JavaScript object instead of a string.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider();
 *
 * export const handler = async (): Promise<void> => {
 *   // Retrieve a parameter and parse it as JSON
 *   const parameter = await parametersProvider.get('/my-parameter', { transform: 'json' });
 *   // Retrieve multiple parameters and parse them as JSON
 *   const parameters = await parametersProvider.getMultiple('/my-parameters-path', { transform: 'json' });
 * };
 * ```
 *
 * For parameters that are instead stored as base64-encoded binary data, you can use the transform argument set to `binary` for decoding. This will return a decoded string.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider();
 *
 * export const handler = async (): Promise<void> => {
 *   // Retrieve a base64-encoded string and decode it
 *   const parameter = await parametersProvider.get('/my-parameter', { transform: 'binary' });
 *   // Retrieve multiple base64-encoded strings and decode them
 *   const parameters = await parametersProvider.getMultiple('/my-parameters-path', { transform: 'binary' });
 * };
 * ```
 *
 * Both type of transformations are compatible also with the `getParametersByName` method.
 *
 * ### Extra SDK options
 *
 * When retrieving parameters, you can pass extra options to the AWS SDK v3 for JavaScript client by using the `sdkOptions` parameter.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider();
 *
 * export const handler = async (): Promise<void> => {
 *   // Retrieve a parameter and pass extra options to the AWS SDK v3 for JavaScript client
 *   const parameter = await parametersProvider.get('/my-parameter', {
 *     sdkOptions: {
 *       WithDecryption: true,
 *     },
 *   });
 * };
 * ```
 *
 * The objects accept the same options as respectively the [AWS SDK v3 for JavaScript GetParameter command](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-ssm/classes/getparametercommand.html) and the [AWS SDK v3 for JavaScript GetParametersByPath command](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-ssm/classes/getparametersbypathcommand.html).
 *
 * ### Customize AWS SDK v3 for JavaScript client
 *
 * By default, the provider will create a new SSM client using the default configuration.
 *
 * You can customize the client by passing a custom configuration object to the provider.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 *
 * const parametersProvider = new SSMProvider({
 *   clientConfig: { region: 'eu-west-1' },
 * });
 * ```
 *
 * This object accepts the same options as the [AWS SDK v3 for JavaScript SSM client constructor](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-ssm/classes/ssmclient.html#constructor).
 *
 * Otherwise, if you want to use a custom client altogether, you can pass it to the provider.
 *
 * @example
 * ```typescript
 * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
 * import { SSMClient } from '@aws-sdk/client-ssm';
 *
 * const client = new SSMClient({ region: 'eu-west-1' });
 * const parametersProvider = new SSMProvider({
 *   awsSdkV3Client: client,
 * });
 * ```
 *
 * This object must be an instance of the [AWS SDK v3 for JavaScript SSM client](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-ssm/classes/ssmclient.html).
 *
 * For more usage examples, see [our documentation](https://docs.powertools.aws.dev/lambda-typescript/latest/utilities/parameters/).
 */
class SSMProvider extends base_1.BaseProvider {
    /**
     * It initializes the SSMProvider class.
     *
     * @param {SSMProviderOptions} config - The configuration object.
     */
    constructor(config) {
        super();
        this.errorsKey = '_errors';
        this.maxGetParametersItems = 10;
        if (config?.awsSdkV3Client) {
            if (config?.awsSdkV3Client instanceof client_ssm_1.SSMClient) {
                this.client = config.awsSdkV3Client;
            }
            else {
                throw Error('Not a valid SSMClient provided');
            }
        }
        else {
            const clientConfig = config?.clientConfig || {};
            this.client = new client_ssm_1.SSMClient(clientConfig);
        }
        (0, commons_1.addUserAgentMiddleware)(this.client, 'parameters');
    }
    /**
     * Retrieve a value from AWS Systems Manager.
     *
     * @example
     * ```typescript
     * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
     *
     * const parametersProvider = new SSMProvider();
     *
     * export const handler = async (): Promise<void> => {
     *   // Retrieve a parameter from SSM
     *   const parameter = await parametersProvider.get('/my-parameter');
     * };
     * ```
     *
     * You can customize the retrieval of the value by passing options to the function:
     * * `maxAge` - The maximum age of the value in cache before fetching a new one (in seconds) (default: 5)
     * * `forceFetch` - Whether to always fetch a new value from the store regardless if already available in cache
     * * `transform` - Whether to transform the value before returning it. Supported values: `json`, `binary`
     * * `sdkOptions` - Extra options to pass to the AWS SDK v3 for JavaScript client
     * * `decrypt` - Whether to decrypt the value before returning it.
     *
     * For usage examples check {@link SSMProvider}.
     *
     * @param {string} name - The name of the value to retrieve (i.e. the partition key)
     * @param {SSMGetOptions} options - Options to configure the provider
     * @see https://docs.powertools.aws.dev/lambda-typescript/latest/utilities/parameters/
     */
    async get(name, options) {
        return super.get(name, options);
    }
    /**
     * Retrieve multiple values from AWS Systems Manager.
     *
     * @example
     * ```typescript
     * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
     *
     * const parametersProvider = new SSMProvider();
     *
     * export const handler = async (): Promise<void> => {
     *   // Retrieve multiple parameters from SSM
     *   const parameters = await parametersProvider.getMultiple('/my-parameters-path');
     * };
     * ```
     *
     * You can customize the retrieval of the values by passing options to the function:
     * * `maxAge` - The maximum age of the value in cache before fetching a new one (in seconds) (default: 5)
     * * `forceFetch` - Whether to always fetch a new value from the store regardless if already available in cache
     * * `transform` - Whether to transform the value before returning it. Supported values: `json`, `binary`
     * * `sdkOptions` - Extra options to pass to the AWS SDK v3 for JavaScript client
     * * `throwOnTransformError` - Whether to throw an error if the transform fails (default: `true`)
     * * `decrypt` - Whether to decrypt the value before returning it.
     * * `recursive` - Whether to recursively retrieve all parameters under the given path (default: `false`)
     *
     * For usage examples check {@link SSMProvider}.
     *
     * @param {string} path - The path of the parameters to retrieve
     * @param {SSMGetMultipleOptions} options - Options to configure the retrieval
     * @see https://docs.powertools.aws.dev/lambda-typescript/latest/utilities/parameters/
     */
    async getMultiple(path, options) {
        return super.getMultiple(path, options);
    }
    /**
     * Retrieve multiple parameters by name from AWS Systems Manager.
     *
     * @example
     * ```typescript
     * import { SSMProvider } from '@aws-lambda-powertools/parameters/ssm';
     *
     * const parametersProvider = new SSMProvider();
     *
     * export const handler = async (): Promise<void> => {
     *   // Retrieve multiple parameters by name from SSM
     *   const parameters = await parametersProvider.getParametersByName({
     *     '/my-parameter-1': {}, // Use default options
     *     '/my-parameter-2': { transform: 'json' }, // Parse the value as JSON
     *   });
     * };
     * ```
     * You can customize the retrieval of the values by passing options to **both the function and the parameter**:
     * * `maxAge` - The maximum age of the value in cache before fetching a new one (in seconds) (default: 5)
     * * `forceFetch` - Whether to always fetch a new value from the store regardless if already available in cache
     * * `transform` - Whether to transform the value before returning it. Supported values: `json`, `binary`
     * * `sdkOptions` - Extra options to pass to the AWS SDK v3 for JavaScript client
     * * `throwOnTransformError` - Whether to throw an error if the transform fails (default: `true`)
     * * `decrypt` - Whether to decrypt the value before returning it
     *
     * `throwOnError` decides whether to throw an error if a parameter is not found:
     * - A) Default fail-fast behavior: Throws a `GetParameterError` error upon any failure.
     * - B) Gracefully aggregate all parameters that failed under "_errors" key.
     *
     * It transparently uses GetParameter and/or GetParameters depending on decryption requirements.
     *
     * ```sh
     *                                ┌────────────────────────┐
     *                            ┌───▶  Decrypt entire batch  │─────┐
     *                            │   └────────────────────────┘     │     ┌────────────────────┐
     *                            │                                  ├─────▶ GetParameters API  │
     *    ┌──────────────────┐    │   ┌────────────────────────┐     │     └────────────────────┘
     *    │   Split batch    │─── ┼──▶│ No decryption required │─────┘
     *    └──────────────────┘    │   └────────────────────────┘
     *                            │                                        ┌────────────────────┐
     *                            │   ┌────────────────────────┐           │  GetParameter API  │
     *                            └──▶│Decrypt some but not all│───────────▶────────────────────┤
     *                                └────────────────────────┘           │ GetParameters API  │
     *                                                                     └────────────────────┘
     * ```
     *
     * @param {Record<string, SSMGetParametersByNameOptions>} parameters - Object containing parameter names and any optional overrides
     * @param {SSMGetParametersByNameOptions} options - Options to configure the retrieval
     * @see https://docs.powertools.aws.dev/lambda-typescript/latest/utilities/parameters/
     */
    async getParametersByName(parameters, options) {
        const configs = {
            ...{
                decrypt: this.resolveDecryptionConfigValue({}) || false,
                maxAge: constants_1.DEFAULT_MAX_AGE_SECS,
                throwOnError: true,
            },
            ...options,
        };
        let response = {};
        // NOTE: We fail early to avoid unintended graceful errors being replaced with their '_errors' param values
        SSMProvider.throwIfErrorsKeyIsPresent(parameters, this.errorsKey, configs.throwOnError);
        const { parametersToFetchInBatch, parametersToDecrypt } = SSMProvider.splitBatchAndDecryptParameters(parameters, configs);
        // NOTE: We need to find out whether all parameters must be decrypted or not to know which API to use
        // Logic:
        // GetParameters API -> When decrypt is used for all parameters in the the batch
        // GetParameter  API -> When decrypt is used for one or more in the batch
        if (Object.keys(parametersToDecrypt).length !== Object.keys(parameters).length) {
            const { response: decryptResponse, errors: decryptErrors } = await this.getParametersByNameWithDecryptOption(parametersToDecrypt, configs.throwOnError);
            const { response: batchResponse, errors: batchErrors } = await this.getParametersBatchByName(parametersToFetchInBatch, configs.throwOnError, false);
            response = { ...decryptResponse, ...batchResponse };
            // Fail-fast disabled, let's aggregate errors under "_errors" key so they can handle gracefully
            if (!configs.throwOnError) {
                response[this.errorsKey] = [...decryptErrors, ...batchErrors];
            }
        }
        else {
            const { response: batchResponse, errors: batchErrors } = await this.getParametersBatchByName(parametersToDecrypt, configs.throwOnError, true);
            response = batchResponse;
            // Fail-fast disabled, let's aggregate errors under "_errors" key so they can handle gracefully
            if (!configs.throwOnError) {
                response[this.errorsKey] = [...batchErrors];
            }
        }
        return response;
    }
    /**
     * Retrieve a parameter from AWS Systems Manager.
     *
     * @param {string} name - Name of the parameter to retrieve
     * @param {SSMGetOptions} options - Options to customize the retrieval
     */
    async _get(name, options) {
        const sdkOptions = {
            ...(options?.sdkOptions || {}),
            Name: name,
        };
        sdkOptions.WithDecryption = this.resolveDecryptionConfigValue(options, sdkOptions);
        const result = await this.client.send(new client_ssm_1.GetParameterCommand(sdkOptions));
        return result.Parameter?.Value;
    }
    /**
     * Retrieve multiple items from AWS Systems Manager.
     *
     * @param {string} path - The path of the parameters to retrieve
     * @param {SSMGetMultipleOptions} options - Options to configure the provider
     */
    async _getMultiple(path, options) {
        const sdkOptions = {
            ...(options?.sdkOptions || {}),
            Path: path,
        };
        const paginationOptions = {
            client: this.client,
        };
        sdkOptions.WithDecryption = this.resolveDecryptionConfigValue(options, sdkOptions);
        sdkOptions.Recursive =
            options?.recursive !== undefined
                ? options.recursive
                : sdkOptions.Recursive;
        paginationOptions.pageSize =
            sdkOptions.MaxResults !== undefined ? sdkOptions.MaxResults : undefined;
        const parameters = {};
        for await (const page of (0, client_ssm_1.paginateGetParametersByPath)(paginationOptions, sdkOptions)) {
            for (const parameter of page.Parameters || []) {
                /**
                 * Standardize the parameter name
                 *
                 * The parameter name returned by SSM will contain the full path.
                 * However, for readability, we should return only the part after the path.
                 **/
                // If the parameter is present in the response, then it has a Name
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                let name = parameter.Name;
                name = name.replace(path, '');
                if (name.startsWith('/')) {
                    name = name.replace('/', '');
                }
                parameters[name] = parameter.Value;
            }
        }
        return parameters;
    }
    /**
     * Retrieve multiple items by name from AWS Systems Manager.
     *
     * @param {Record<string, SSMGetParametersByNameOptions>} parameters - An object of parameter names and their options
     * @param {throwOnError} throwOnError - Whether to throw an error if any of the parameters' retrieval throws an error or handle them gracefully
     * @param {boolean} decrypt - Whether to decrypt the parameters or not
     */
    async _getParametersByName(parameters, throwOnError, decrypt) {
        const sdkOptions = {
            Names: Object.keys(parameters),
        };
        if (decrypt) {
            sdkOptions.WithDecryption = true;
        }
        const result = await this.client.send(new client_ssm_1.GetParametersCommand(sdkOptions));
        const errors = SSMProvider.handleAnyInvalidGetParameterErrors(result, throwOnError);
        const response = this.transformAndCacheGetParametersResponse(result, parameters, throwOnError);
        return {
            response,
            errors,
        };
    }
    /**
     * Slice batch and fetch parameters using GetPrameters API by max permissible batch size
     *
     * @param {Record<string, SSMGetParametersByNameOptions>} parameters - An object of parameter names and their options
     * @param {throwOnError} throwOnError - Whether to throw an error if any of the parameters' retrieval throws an error or handle them gracefully
     * @param {boolean} decrypt - Whether to decrypt the parameters or not
     */
    async getParametersBatchByName(parameters, throwOnError, decrypt) {
        let response = {};
        let errors = [];
        // Fetch each possible batch param from cache and return if entire batch is cached
        const { cached, toFetch } = await this.getParametersByNameFromCache(parameters);
        if (Object.keys(cached).length >= Object.keys(parameters).length) {
            response = cached;
            return {
                response,
                errors,
            };
        }
        // Slice batch by max permitted GetParameters call and retrieve the ones that are not cached
        const { response: batchResponse, errors: batchErrors } = await this.getParametersByNameInChunks(toFetch, throwOnError, decrypt);
        response = { ...cached, ...batchResponse };
        errors = batchErrors;
        return {
            response,
            errors,
        };
    }
    /**
     * Fetch each parameter from batch that hasn't expired from cache
     *
     * @param {Record<string, SSMGetParametersByNameOptions>} parameters - An object of parameter names and their options
     */
    async getParametersByNameFromCache(parameters) {
        const cached = {};
        const toFetch = {};
        for (const [parameterName, parameterOptions] of Object.entries(parameters)) {
            const cacheKey = [parameterName, parameterOptions.transform].toString();
            if (!this.hasKeyExpiredInCache(cacheKey)) {
                // Since we know the key exists in the cache, we can safely use the non-null assertion operator
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                cached[parameterName] = this.store.get(cacheKey).value;
            }
            else {
                toFetch[parameterName] = parameterOptions;
            }
        }
        return {
            cached,
            toFetch,
        };
    }
    /**
     * Slice object into chunks of max permissible batch size and fetch parameters
     *
     * @param {Record<string, SSMGetParametersByNameOptions>} parameters - An object of parameter names and their options
     * @param {boolean} throwOnError - Whether to throw an error if any of the parameters' retrieval throws an error or handle them gracefully
     * @param {boolean} decrypt - Whether to decrypt the parameters or not
     */
    async getParametersByNameInChunks(parameters, throwOnError, decrypt) {
        let response = {};
        let errors = [];
        // Slice object into chunks of max permissible batch size
        const chunks = Object.entries(parameters).reduce((acc, [parameterName, parameterOptions], index) => {
            const chunkIndex = Math.floor(index / this.maxGetParametersItems);
            if (!acc[chunkIndex]) {
                acc[chunkIndex] = {};
            }
            acc[chunkIndex][parameterName] = parameterOptions;
            return acc;
        }, []);
        // Fetch each chunk and merge results
        for (const chunk of chunks) {
            const { response: chunkResponse, errors: chunkErrors } = await this._getParametersByName(chunk, throwOnError, decrypt);
            response = { ...response, ...chunkResponse };
            errors = [...errors, ...chunkErrors];
        }
        return {
            response,
            errors,
        };
    }
    /**
     * Fetch parameters by name while also decrypting them
     *
     * @param {Record<string, SSMGetParametersByNameOptions>} parameters - An object of parameter names and their options
     * @param {boolean} throwOnError - Whether to throw an error if any of the parameters' retrieval throws an error or handle them gracefully
     */
    async getParametersByNameWithDecryptOption(parameters, throwOnError) {
        const response = {};
        const errors = [];
        for (const [parameterName, parameterOptions] of Object.entries(parameters)) {
            try {
                response[parameterName] = await this._get(parameterName, parameterOptions);
            }
            catch (error) {
                if (throwOnError) {
                    throw error;
                }
                errors.push(parameterName);
            }
        }
        return {
            response,
            errors,
        };
    }
    /**
     * Handle any invalid parameters returned by GetParameters API
     * GetParameters is non-atomic. Failures don't always reflect in exceptions so we need to collect.
     *
     * @param {GetParametersCommandOutput} result - The result of the GetParameters API call
     * @param {boolean} throwOnError - Whether to throw an error if any of the parameters' retrieval throws an error or handle them gracefully
     */
    static handleAnyInvalidGetParameterErrors(result, throwOnError) {
        const errors = [];
        if (result.InvalidParameters && result.InvalidParameters.length > 0) {
            if (throwOnError) {
                throw new errors_1.GetParameterError(`Failed to fetch parameters: ${result.InvalidParameters.join(', ')}`);
            }
            errors.push(...result.InvalidParameters);
        }
        return errors;
    }
    resolveDecryptionConfigValue(options = {}, sdkOptions) {
        if (options?.decrypt !== undefined)
            return options.decrypt;
        if (sdkOptions?.WithDecryption !== undefined)
            return sdkOptions.WithDecryption;
        if (this.envVarsService.getSSMDecrypt() !== '') {
            return this.envVarsService.isValueTrue(this.envVarsService.getSSMDecrypt());
        }
        return undefined;
    }
    /**
     * Split parameters that can be fetched by GetParameters vs GetParameter.
     *
     * @param {Record<string, SSMGetParametersByNameOptions>} parameters - An object of parameter names and their options
     * @param {SSMGetParametersByNameOptions} configs - The configs passed down
     */
    static splitBatchAndDecryptParameters(parameters, configs) {
        const parametersToFetchInBatch = {};
        const parametersToDecrypt = {};
        for (const [parameterName, parameterOptions] of Object.entries(parameters)) {
            const overrides = parameterOptions;
            overrides.transform = overrides.transform || configs.transform;
            overrides.decrypt =
                overrides.decrypt !== undefined ? overrides.decrypt : configs.decrypt;
            overrides.maxAge =
                overrides.maxAge !== undefined ? overrides.maxAge : configs.maxAge;
            if (overrides.decrypt) {
                parametersToDecrypt[parameterName] = overrides;
            }
            else {
                parametersToFetchInBatch[parameterName] = overrides;
            }
        }
        return {
            parametersToFetchInBatch,
            parametersToDecrypt,
        };
    }
    /**
     * Throw a GetParameterError if fail-fast is disabled and `_errors` key is in parameters list.
     *
     * @param {Record<string, unknown>} parameters
     * @param {string} reservedParameter
     * @param {boolean} throwOnError
     */
    static throwIfErrorsKeyIsPresent(parameters, reservedParameter, throwOnError) {
        if (!throwOnError && parameters.hasOwnProperty(reservedParameter)) {
            throw new errors_1.GetParameterError(`You cannot fetch a parameter named ${reservedParameter} in graceful error mode.`);
        }
    }
    /**
     * Transform and cache the response from GetParameters API call
     *
     * @param {GetParametersCommandOutput} response - The response from the GetParameters API call
     * @param {Record<string, SSMGetParametersByNameOptions>} parameters - An object of parameter names and their options
     * @param {boolean} throwOnError - Whether to throw an error if any of the parameters' retrieval throws an error or handle them gracefully
     */
    transformAndCacheGetParametersResponse(response, parameters, throwOnError) {
        const processedParameters = {};
        for (const parameter of response.Parameters || []) {
            // If the parameter is present in the response, then it has a Name
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const parameterName = parameter.Name;
            const parameterValue = parameter.Value;
            const parameterOptions = parameters[parameterName];
            let value;
            // NOTE: if transform is set, we do it before caching to reduce number of operations
            if (parameterValue && parameterOptions.transform) {
                value = (0, transformValue_1.transformValue)(parameterValue, parameterOptions.transform, throwOnError, parameterName);
            }
            else if (parameterValue) {
                value = parameterValue;
            }
            if (value) {
                const cacheKey = [parameterName, parameterOptions.transform].toString();
                this.addToCache(cacheKey, value, parameterOptions.maxAge || constants_1.DEFAULT_MAX_AGE_SECS);
            }
            processedParameters[parameterName] = value;
        }
        return processedParameters;
    }
}
exports.SSMProvider = SSMProvider;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU1NNUHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc3NtL1NTTVByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGtDQUEwRDtBQTA1QnBDLGtHQTE1QkMsd0JBQWlCLE9BMDVCRDtBQXo1QnZDLDJEQUF3RDtBQUN4RCxzQ0FBOEM7QUFDOUMsNENBQW9EO0FBQ3BELG9EQUs2QjtBQW9CN0IsNERBQXdFO0FBRXhFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBOE9HO0FBQ0gsTUFBTSxXQUFZLFNBQVEsbUJBQVk7SUFLcEM7Ozs7T0FJRztJQUNILFlBQW1CLE1BQTJCO1FBQzVDLEtBQUssRUFBRSxDQUFDO1FBVEEsY0FBUyxHQUFHLFNBQVMsQ0FBQztRQUN0QiwwQkFBcUIsR0FBRyxFQUFFLENBQUM7UUFVbkMsSUFBSSxNQUFNLEVBQUUsY0FBYyxFQUFFO1lBQzFCLElBQUksTUFBTSxFQUFFLGNBQWMsWUFBWSxzQkFBUyxFQUFFO2dCQUMvQyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUM7YUFDckM7aUJBQU07Z0JBQ0wsTUFBTSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQzthQUMvQztTQUNGO2FBQU07WUFDTCxNQUFNLFlBQVksR0FBRyxNQUFNLEVBQUUsWUFBWSxJQUFJLEVBQUUsQ0FBQztZQUNoRCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksc0JBQVMsQ0FBQyxZQUFZLENBQUMs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