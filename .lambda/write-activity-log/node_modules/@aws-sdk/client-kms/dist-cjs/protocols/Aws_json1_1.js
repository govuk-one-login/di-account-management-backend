"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.se_VerifyMacCommand = exports.se_VerifyCommand = exports.se_UpdatePrimaryRegionCommand = exports.se_UpdateKeyDescriptionCommand = exports.se_UpdateCustomKeyStoreCommand = exports.se_UpdateAliasCommand = exports.se_UntagResourceCommand = exports.se_TagResourceCommand = exports.se_SignCommand = exports.se_ScheduleKeyDeletionCommand = exports.se_RevokeGrantCommand = exports.se_RetireGrantCommand = exports.se_ReplicateKeyCommand = exports.se_ReEncryptCommand = exports.se_PutKeyPolicyCommand = exports.se_ListRetirableGrantsCommand = exports.se_ListResourceTagsCommand = exports.se_ListKeysCommand = exports.se_ListKeyPoliciesCommand = exports.se_ListGrantsCommand = exports.se_ListAliasesCommand = exports.se_ImportKeyMaterialCommand = exports.se_GetPublicKeyCommand = exports.se_GetParametersForImportCommand = exports.se_GetKeyRotationStatusCommand = exports.se_GetKeyPolicyCommand = exports.se_GenerateRandomCommand = exports.se_GenerateMacCommand = exports.se_GenerateDataKeyWithoutPlaintextCommand = exports.se_GenerateDataKeyPairWithoutPlaintextCommand = exports.se_GenerateDataKeyPairCommand = exports.se_GenerateDataKeyCommand = exports.se_EncryptCommand = exports.se_EnableKeyRotationCommand = exports.se_EnableKeyCommand = exports.se_DisconnectCustomKeyStoreCommand = exports.se_DisableKeyRotationCommand = exports.se_DisableKeyCommand = exports.se_DescribeKeyCommand = exports.se_DescribeCustomKeyStoresCommand = exports.se_DeleteImportedKeyMaterialCommand = exports.se_DeleteCustomKeyStoreCommand = exports.se_DeleteAliasCommand = exports.se_DecryptCommand = exports.se_CreateKeyCommand = exports.se_CreateGrantCommand = exports.se_CreateCustomKeyStoreCommand = exports.se_CreateAliasCommand = exports.se_ConnectCustomKeyStoreCommand = exports.se_CancelKeyDeletionCommand = void 0;
exports.de_VerifyMacCommand = exports.de_VerifyCommand = exports.de_UpdatePrimaryRegionCommand = exports.de_UpdateKeyDescriptionCommand = exports.de_UpdateCustomKeyStoreCommand = exports.de_UpdateAliasCommand = exports.de_UntagResourceCommand = exports.de_TagResourceCommand = exports.de_SignCommand = exports.de_ScheduleKeyDeletionCommand = exports.de_RevokeGrantCommand = exports.de_RetireGrantCommand = exports.de_ReplicateKeyCommand = exports.de_ReEncryptCommand = exports.de_PutKeyPolicyCommand = exports.de_ListRetirableGrantsCommand = exports.de_ListResourceTagsCommand = exports.de_ListKeysCommand = exports.de_ListKeyPoliciesCommand = exports.de_ListGrantsCommand = exports.de_ListAliasesCommand = exports.de_ImportKeyMaterialCommand = exports.de_GetPublicKeyCommand = exports.de_GetParametersForImportCommand = exports.de_GetKeyRotationStatusCommand = exports.de_GetKeyPolicyCommand = exports.de_GenerateRandomCommand = exports.de_GenerateMacCommand = exports.de_GenerateDataKeyWithoutPlaintextCommand = exports.de_GenerateDataKeyPairWithoutPlaintextCommand = exports.de_GenerateDataKeyPairCommand = exports.de_GenerateDataKeyCommand = exports.de_EncryptCommand = exports.de_EnableKeyRotationCommand = exports.de_EnableKeyCommand = exports.de_DisconnectCustomKeyStoreCommand = exports.de_DisableKeyRotationCommand = exports.de_DisableKeyCommand = exports.de_DescribeKeyCommand = exports.de_DescribeCustomKeyStoresCommand = exports.de_DeleteImportedKeyMaterialCommand = exports.de_DeleteCustomKeyStoreCommand = exports.de_DeleteAliasCommand = exports.de_DecryptCommand = exports.de_CreateKeyCommand = exports.de_CreateGrantCommand = exports.de_CreateCustomKeyStoreCommand = exports.de_CreateAliasCommand = exports.de_ConnectCustomKeyStoreCommand = exports.de_CancelKeyDeletionCommand = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const smithy_client_1 = require("@smithy/smithy-client");
const KMSServiceException_1 = require("../models/KMSServiceException");
const models_0_1 = require("../models/models_0");
const se_CancelKeyDeletionCommand = async (input, context) => {
    const headers = sharedHeaders("CancelKeyDeletion");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CancelKeyDeletionCommand = se_CancelKeyDeletionCommand;
const se_ConnectCustomKeyStoreCommand = async (input, context) => {
    const headers = sharedHeaders("ConnectCustomKeyStore");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ConnectCustomKeyStoreCommand = se_ConnectCustomKeyStoreCommand;
const se_CreateAliasCommand = async (input, context) => {
    const headers = sharedHeaders("CreateAlias");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateAliasCommand = se_CreateAliasCommand;
const se_CreateCustomKeyStoreCommand = async (input, context) => {
    const headers = sharedHeaders("CreateCustomKeyStore");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateCustomKeyStoreCommand = se_CreateCustomKeyStoreCommand;
const se_CreateGrantCommand = async (input, context) => {
    const headers = sharedHeaders("CreateGrant");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateGrantCommand = se_CreateGrantCommand;
const se_CreateKeyCommand = async (input, context) => {
    const headers = sharedHeaders("CreateKey");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateKeyCommand = se_CreateKeyCommand;
const se_DecryptCommand = async (input, context) => {
    const headers = sharedHeaders("Decrypt");
    let body;
    body = JSON.stringify(se_DecryptRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DecryptCommand = se_DecryptCommand;
const se_DeleteAliasCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteAlias");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteAliasCommand = se_DeleteAliasCommand;
const se_DeleteCustomKeyStoreCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteCustomKeyStore");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteCustomKeyStoreCommand = se_DeleteCustomKeyStoreCommand;
const se_DeleteImportedKeyMaterialCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteImportedKeyMaterial");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteImportedKeyMaterialCommand = se_DeleteImportedKeyMaterialCommand;
const se_DescribeCustomKeyStoresCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeCustomKeyStores");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeCustomKeyStoresCommand = se_DescribeCustomKeyStoresCommand;
const se_DescribeKeyCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeKey");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeKeyCommand = se_DescribeKeyCommand;
const se_DisableKeyCommand = async (input, context) => {
    const headers = sharedHeaders("DisableKey");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DisableKeyCommand = se_DisableKeyCommand;
const se_DisableKeyRotationCommand = async (input, context) => {
    const headers = sharedHeaders("DisableKeyRotation");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DisableKeyRotationCommand = se_DisableKeyRotationCommand;
const se_DisconnectCustomKeyStoreCommand = async (input, context) => {
    const headers = sharedHeaders("DisconnectCustomKeyStore");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DisconnectCustomKeyStoreCommand = se_DisconnectCustomKeyStoreCommand;
const se_EnableKeyCommand = async (input, context) => {
    const headers = sharedHeaders("EnableKey");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_EnableKeyCommand = se_EnableKeyCommand;
const se_EnableKeyRotationCommand = async (input, context) => {
    const headers = sharedHeaders("EnableKeyRotation");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_EnableKeyRotationCommand = se_EnableKeyRotationCommand;
const se_EncryptCommand = async (input, context) => {
    const headers = sharedHeaders("Encrypt");
    let body;
    body = JSON.stringify(se_EncryptRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_EncryptCommand = se_EncryptCommand;
const se_GenerateDataKeyCommand = async (input, context) => {
    const headers = sharedHeaders("GenerateDataKey");
    let body;
    body = JSON.stringify(se_GenerateDataKeyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GenerateDataKeyCommand = se_GenerateDataKeyCommand;
const se_GenerateDataKeyPairCommand = async (input, context) => {
    const headers = sharedHeaders("GenerateDataKeyPair");
    let body;
    body = JSON.stringify(se_GenerateDataKeyPairRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GenerateDataKeyPairCommand = se_GenerateDataKeyPairCommand;
const se_GenerateDataKeyPairWithoutPlaintextCommand = async (input, context) => {
    const headers = sharedHeaders("GenerateDataKeyPairWithoutPlaintext");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GenerateDataKeyPairWithoutPlaintextCommand = se_GenerateDataKeyPairWithoutPlaintextCommand;
const se_GenerateDataKeyWithoutPlaintextCommand = async (input, context) => {
    const headers = sharedHeaders("GenerateDataKeyWithoutPlaintext");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GenerateDataKeyWithoutPlaintextCommand = se_GenerateDataKeyWithoutPlaintextCommand;
const se_GenerateMacCommand = async (input, context) => {
    const headers = sharedHeaders("GenerateMac");
    let body;
    body = JSON.stringify(se_GenerateMacRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GenerateMacCommand = se_GenerateMacCommand;
const se_GenerateRandomCommand = async (input, context) => {
    const headers = sharedHeaders("GenerateRandom");
    let body;
    body = JSON.stringify(se_GenerateRandomRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GenerateRandomCommand = se_GenerateRandomCommand;
const se_GetKeyPolicyCommand = async (input, context) => {
    const headers = sharedHeaders("GetKeyPolicy");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetKeyPolicyCommand = se_GetKeyPolicyCommand;
const se_GetKeyRotationStatusCommand = async (input, context) => {
    const headers = sharedHeaders("GetKeyRotationStatus");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetKeyRotationStatusCommand = se_GetKeyRotationStatusCommand;
const se_GetParametersForImportCommand = async (input, context) => {
    const headers = sharedHeaders("GetParametersForImport");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetParametersForImportCommand = se_GetParametersForImportCommand;
const se_GetPublicKeyCommand = async (input, context) => {
    const headers = sharedHeaders("GetPublicKey");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetPublicKeyCommand = se_GetPublicKeyCommand;
const se_ImportKeyMaterialCommand = async (input, context) => {
    const headers = sharedHeaders("ImportKeyMaterial");
    let body;
    body = JSON.stringify(se_ImportKeyMaterialRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ImportKeyMaterialCommand = se_ImportKeyMaterialCommand;
const se_ListAliasesCommand = async (input, context) => {
    const headers = sharedHeaders("ListAliases");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListAliasesCommand = se_ListAliasesCommand;
const se_ListGrantsCommand = async (input, context) => {
    const headers = sharedHeaders("ListGrants");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListGrantsCommand = se_ListGrantsCommand;
const se_ListKeyPoliciesCommand = async (input, context) => {
    const headers = sharedHeaders("ListKeyPolicies");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListKeyPoliciesCommand = se_ListKeyPoliciesCommand;
const se_ListKeysCommand = async (input, context) => {
    const headers = sharedHeaders("ListKeys");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListKeysCommand = se_ListKeysCommand;
const se_ListResourceTagsCommand = async (input, context) => {
    const headers = sharedHeaders("ListResourceTags");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListResourceTagsCommand = se_ListResourceTagsCommand;
const se_ListRetirableGrantsCommand = async (input, context) => {
    const headers = sharedHeaders("ListRetirableGrants");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListRetirableGrantsCommand = se_ListRetirableGrantsCommand;
const se_PutKeyPolicyCommand = async (input, context) => {
    const headers = sharedHeaders("PutKeyPolicy");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutKeyPolicyCommand = se_PutKeyPolicyCommand;
const se_ReEncryptCommand = async (input, context) => {
    const headers = sharedHeaders("ReEncrypt");
    let body;
    body = JSON.stringify(se_ReEncryptRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ReEncryptCommand = se_ReEncryptCommand;
const se_ReplicateKeyCommand = async (input, context) => {
    const headers = sharedHeaders("ReplicateKey");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ReplicateKeyCommand = se_ReplicateKeyCommand;
const se_RetireGrantCommand = async (input, context) => {
    const headers = sharedHeaders("RetireGrant");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RetireGrantCommand = se_RetireGrantCommand;
const se_RevokeGrantCommand = async (input, context) => {
    const headers = sharedHeaders("RevokeGrant");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RevokeGrantCommand = se_RevokeGrantCommand;
const se_ScheduleKeyDeletionCommand = async (input, context) => {
    const headers = sharedHeaders("ScheduleKeyDeletion");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ScheduleKeyDeletionCommand = se_ScheduleKeyDeletionCommand;
const se_SignCommand = async (input, context) => {
    const headers = sharedHeaders("Sign");
    let body;
    body = JSON.stringify(se_SignRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SignCommand = se_SignCommand;
const se_TagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_UntagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateAliasCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateAlias");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateAliasCommand = se_UpdateAliasCommand;
const se_UpdateCustomKeyStoreCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateCustomKeyStore");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateCustomKeyStoreCommand = se_UpdateCustomKeyStoreCommand;
const se_UpdateKeyDescriptionCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateKeyDescription");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateKeyDescriptionCommand = se_UpdateKeyDescriptionCommand;
const se_UpdatePrimaryRegionCommand = async (input, context) => {
    const headers = sharedHeaders("UpdatePrimaryRegion");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdatePrimaryRegionCommand = se_UpdatePrimaryRegionCommand;
const se_VerifyCommand = async (input, context) => {
    const headers = sharedHeaders("Verify");
    let body;
    body = JSON.stringify(se_VerifyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_VerifyCommand = se_VerifyCommand;
const se_VerifyMacCommand = async (input, context) => {
    const headers = sharedHeaders("VerifyMac");
    let body;
    body = JSON.stringify(se_VerifyMacRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_VerifyMacCommand = se_VerifyMacCommand;
const de_CancelKeyDeletionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CancelKeyDeletionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CancelKeyDeletionCommand = de_CancelKeyDeletionCommand;
const de_CancelKeyDeletionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ConnectCustomKeyStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ConnectCustomKeyStoreCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ConnectCustomKeyStoreCommand = de_ConnectCustomKeyStoreCommand;
const de_ConnectCustomKeyStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudHsmClusterInvalidConfigurationException":
        case "com.amazonaws.kms#CloudHsmClusterInvalidConfigurationException":
            throw await de_CloudHsmClusterInvalidConfigurationExceptionRes(parsedOutput, context);
        case "CloudHsmClusterNotActiveException":
        case "com.amazonaws.kms#CloudHsmClusterNotActiveException":
            throw await de_CloudHsmClusterNotActiveExceptionRes(parsedOutput, context);
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await de_CustomKeyStoreInvalidStateExceptionRes(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await de_CustomKeyStoreNotFoundExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAliasCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_CreateAliasCommand = de_CreateAliasCommand;
const de_CreateAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.kms#AlreadyExistsException":
            throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidAliasNameException":
        case "com.amazonaws.kms#InvalidAliasNameException":
            throw await de_InvalidAliasNameExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateCustomKeyStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateCustomKeyStoreCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateCustomKeyStoreCommand = de_CreateCustomKeyStoreCommand;
const de_CreateCustomKeyStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudHsmClusterInUseException":
        case "com.amazonaws.kms#CloudHsmClusterInUseException":
            throw await de_CloudHsmClusterInUseExceptionRes(parsedOutput, context);
        case "CloudHsmClusterInvalidConfigurationException":
        case "com.amazonaws.kms#CloudHsmClusterInvalidConfigurationException":
            throw await de_CloudHsmClusterInvalidConfigurationExceptionRes(parsedOutput, context);
        case "CloudHsmClusterNotActiveException":
        case "com.amazonaws.kms#CloudHsmClusterNotActiveException":
            throw await de_CloudHsmClusterNotActiveExceptionRes(parsedOutput, context);
        case "CloudHsmClusterNotFoundException":
        case "com.amazonaws.kms#CloudHsmClusterNotFoundException":
            throw await de_CloudHsmClusterNotFoundExceptionRes(parsedOutput, context);
        case "CustomKeyStoreNameInUseException":
        case "com.amazonaws.kms#CustomKeyStoreNameInUseException":
            throw await de_CustomKeyStoreNameInUseExceptionRes(parsedOutput, context);
        case "IncorrectTrustAnchorException":
        case "com.amazonaws.kms#IncorrectTrustAnchorException":
            throw await de_IncorrectTrustAnchorExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "XksProxyIncorrectAuthenticationCredentialException":
        case "com.amazonaws.kms#XksProxyIncorrectAuthenticationCredentialException":
            throw await de_XksProxyIncorrectAuthenticationCredentialExceptionRes(parsedOutput, context);
        case "XksProxyInvalidConfigurationException":
        case "com.amazonaws.kms#XksProxyInvalidConfigurationException":
            throw await de_XksProxyInvalidConfigurationExceptionRes(parsedOutput, context);
        case "XksProxyInvalidResponseException":
        case "com.amazonaws.kms#XksProxyInvalidResponseException":
            throw await de_XksProxyInvalidResponseExceptionRes(parsedOutput, context);
        case "XksProxyUriEndpointInUseException":
        case "com.amazonaws.kms#XksProxyUriEndpointInUseException":
            throw await de_XksProxyUriEndpointInUseExceptionRes(parsedOutput, context);
        case "XksProxyUriInUseException":
        case "com.amazonaws.kms#XksProxyUriInUseException":
            throw await de_XksProxyUriInUseExceptionRes(parsedOutput, context);
        case "XksProxyUriUnreachableException":
        case "com.amazonaws.kms#XksProxyUriUnreachableException":
            throw await de_XksProxyUriUnreachableExceptionRes(parsedOutput, context);
        case "XksProxyVpcEndpointServiceInUseException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceInUseException":
            throw await de_XksProxyVpcEndpointServiceInUseExceptionRes(parsedOutput, context);
        case "XksProxyVpcEndpointServiceInvalidConfigurationException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceInvalidConfigurationException":
            throw await de_XksProxyVpcEndpointServiceInvalidConfigurationExceptionRes(parsedOutput, context);
        case "XksProxyVpcEndpointServiceNotFoundException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceNotFoundException":
            throw await de_XksProxyVpcEndpointServiceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateGrantCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateGrantCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateGrantCommand = de_CreateGrantCommand;
const de_CreateGrantCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateKeyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateKeyCommand = de_CreateKeyCommand;
const de_CreateKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudHsmClusterInvalidConfigurationException":
        case "com.amazonaws.kms#CloudHsmClusterInvalidConfigurationException":
            throw await de_CloudHsmClusterInvalidConfigurationExceptionRes(parsedOutput, context);
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await de_CustomKeyStoreInvalidStateExceptionRes(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await de_CustomKeyStoreNotFoundExceptionRes(parsedOutput, context);
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocumentException":
        case "com.amazonaws.kms#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "TagException":
        case "com.amazonaws.kms#TagException":
            throw await de_TagExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        case "XksKeyAlreadyInUseException":
        case "com.amazonaws.kms#XksKeyAlreadyInUseException":
            throw await de_XksKeyAlreadyInUseExceptionRes(parsedOutput, context);
        case "XksKeyInvalidConfigurationException":
        case "com.amazonaws.kms#XksKeyInvalidConfigurationException":
            throw await de_XksKeyInvalidConfigurationExceptionRes(parsedOutput, context);
        case "XksKeyNotFoundException":
        case "com.amazonaws.kms#XksKeyNotFoundException":
            throw await de_XksKeyNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DecryptCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DecryptCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DecryptResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DecryptCommand = de_DecryptCommand;
const de_DecryptCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "IncorrectKeyException":
        case "com.amazonaws.kms#IncorrectKeyException":
            throw await de_IncorrectKeyExceptionRes(parsedOutput, context);
        case "InvalidCiphertextException":
        case "com.amazonaws.kms#InvalidCiphertextException":
            throw await de_InvalidCiphertextExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAliasCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteAliasCommand = de_DeleteAliasCommand;
const de_DeleteAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteCustomKeyStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteCustomKeyStoreCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteCustomKeyStoreCommand = de_DeleteCustomKeyStoreCommand;
const de_DeleteCustomKeyStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CustomKeyStoreHasCMKsException":
        case "com.amazonaws.kms#CustomKeyStoreHasCMKsException":
            throw await de_CustomKeyStoreHasCMKsExceptionRes(parsedOutput, context);
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await de_CustomKeyStoreInvalidStateExceptionRes(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await de_CustomKeyStoreNotFoundExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteImportedKeyMaterialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteImportedKeyMaterialCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DeleteImportedKeyMaterialCommand = de_DeleteImportedKeyMaterialCommand;
const de_DeleteImportedKeyMaterialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeCustomKeyStoresCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeCustomKeyStoresCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCustomKeyStoresResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeCustomKeyStoresCommand = de_DescribeCustomKeyStoresCommand;
const de_DescribeCustomKeyStoresCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await de_CustomKeyStoreNotFoundExceptionRes(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await de_InvalidMarkerExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeKeyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeKeyCommand = de_DescribeKeyCommand;
const de_DescribeKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisableKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisableKeyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DisableKeyCommand = de_DisableKeyCommand;
const de_DisableKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisableKeyRotationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisableKeyRotationCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DisableKeyRotationCommand = de_DisableKeyRotationCommand;
const de_DisableKeyRotationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisconnectCustomKeyStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisconnectCustomKeyStoreCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DisconnectCustomKeyStoreCommand = de_DisconnectCustomKeyStoreCommand;
const de_DisconnectCustomKeyStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await de_CustomKeyStoreInvalidStateExceptionRes(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await de_CustomKeyStoreNotFoundExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_EnableKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnableKeyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_EnableKeyCommand = de_EnableKeyCommand;
const de_EnableKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_EnableKeyRotationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnableKeyRotationCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_EnableKeyRotationCommand = de_EnableKeyRotationCommand;
const de_EnableKeyRotationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_EncryptCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EncryptCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EncryptResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_EncryptCommand = de_EncryptCommand;
const de_EncryptCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GenerateDataKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateDataKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateDataKeyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GenerateDataKeyCommand = de_GenerateDataKeyCommand;
const de_GenerateDataKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GenerateDataKeyPairCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateDataKeyPairCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateDataKeyPairResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GenerateDataKeyPairCommand = de_GenerateDataKeyPairCommand;
const de_GenerateDataKeyPairCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GenerateDataKeyPairWithoutPlaintextCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateDataKeyPairWithoutPlaintextCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateDataKeyPairWithoutPlaintextResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GenerateDataKeyPairWithoutPlaintextCommand = de_GenerateDataKeyPairWithoutPlaintextCommand;
const de_GenerateDataKeyPairWithoutPlaintextCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GenerateDataKeyWithoutPlaintextCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateDataKeyWithoutPlaintextCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateDataKeyWithoutPlaintextResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GenerateDataKeyWithoutPlaintextCommand = de_GenerateDataKeyWithoutPlaintextCommand;
const de_GenerateDataKeyWithoutPlaintextCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GenerateMacCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateMacCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateMacResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GenerateMacCommand = de_GenerateMacCommand;
const de_GenerateMacCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GenerateRandomCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateRandomCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateRandomResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GenerateRandomCommand = de_GenerateRandomCommand;
const de_GenerateRandomCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await de_CustomKeyStoreInvalidStateExceptionRes(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await de_CustomKeyStoreNotFoundExceptionRes(parsedOutput, context);
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetKeyPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetKeyPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetKeyPolicyCommand = de_GetKeyPolicyCommand;
const de_GetKeyPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetKeyRotationStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetKeyRotationStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetKeyRotationStatusCommand = de_GetKeyRotationStatusCommand;
const de_GetKeyRotationStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetParametersForImportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetParametersForImportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetParametersForImportResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetParametersForImportCommand = de_GetParametersForImportCommand;
const de_GetParametersForImportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPublicKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPublicKeyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetPublicKeyCommand = de_GetPublicKeyCommand;
const de_GetPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ImportKeyMaterialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ImportKeyMaterialCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ImportKeyMaterialCommand = de_ImportKeyMaterialCommand;
const de_ImportKeyMaterialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "ExpiredImportTokenException":
        case "com.amazonaws.kms#ExpiredImportTokenException":
            throw await de_ExpiredImportTokenExceptionRes(parsedOutput, context);
        case "IncorrectKeyMaterialException":
        case "com.amazonaws.kms#IncorrectKeyMaterialException":
            throw await de_IncorrectKeyMaterialExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidCiphertextException":
        case "com.amazonaws.kms#InvalidCiphertextException":
            throw await de_InvalidCiphertextExceptionRes(parsedOutput, context);
        case "InvalidImportTokenException":
        case "com.amazonaws.kms#InvalidImportTokenException":
            throw await de_InvalidImportTokenExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAliasesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAliasesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAliasesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListAliasesCommand = de_ListAliasesCommand;
const de_ListAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await de_InvalidMarkerExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListGrantsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListGrantsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGrantsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListGrantsCommand = de_ListGrantsCommand;
const de_ListGrantsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidGrantIdException":
        case "com.amazonaws.kms#InvalidGrantIdException":
            throw await de_InvalidGrantIdExceptionRes(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await de_InvalidMarkerExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListKeyPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListKeyPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListKeyPoliciesCommand = de_ListKeyPoliciesCommand;
const de_ListKeyPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListKeysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListKeysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListKeysCommand = de_ListKeysCommand;
const de_ListKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await de_InvalidMarkerExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListResourceTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListResourceTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListResourceTagsCommand = de_ListResourceTagsCommand;
const de_ListResourceTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await de_InvalidMarkerExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListRetirableGrantsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListRetirableGrantsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGrantsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListRetirableGrantsCommand = de_ListRetirableGrantsCommand;
const de_ListRetirableGrantsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await de_InvalidMarkerExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutKeyPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutKeyPolicyCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_PutKeyPolicyCommand = de_PutKeyPolicyCommand;
const de_PutKeyPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocumentException":
        case "com.amazonaws.kms#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ReEncryptCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ReEncryptCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReEncryptResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ReEncryptCommand = de_ReEncryptCommand;
const de_ReEncryptCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "IncorrectKeyException":
        case "com.amazonaws.kms#IncorrectKeyException":
            throw await de_IncorrectKeyExceptionRes(parsedOutput, context);
        case "InvalidCiphertextException":
        case "com.amazonaws.kms#InvalidCiphertextException":
            throw await de_InvalidCiphertextExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ReplicateKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ReplicateKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReplicateKeyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ReplicateKeyCommand = de_ReplicateKeyCommand;
const de_ReplicateKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.kms#AlreadyExistsException":
            throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocumentException":
        case "com.amazonaws.kms#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TagException":
        case "com.amazonaws.kms#TagException":
            throw await de_TagExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RetireGrantCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RetireGrantCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_RetireGrantCommand = de_RetireGrantCommand;
const de_RetireGrantCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidGrantIdException":
        case "com.amazonaws.kms#InvalidGrantIdException":
            throw await de_InvalidGrantIdExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RevokeGrantCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RevokeGrantCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_RevokeGrantCommand = de_RevokeGrantCommand;
const de_RevokeGrantCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "InvalidGrantIdException":
        case "com.amazonaws.kms#InvalidGrantIdException":
            throw await de_InvalidGrantIdExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ScheduleKeyDeletionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ScheduleKeyDeletionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ScheduleKeyDeletionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ScheduleKeyDeletionCommand = de_ScheduleKeyDeletionCommand;
const de_ScheduleKeyDeletionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_SignCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SignCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SignResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_SignCommand = de_SignCommand;
const de_SignCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TagException":
        case "com.amazonaws.kms#TagException":
            throw await de_TagExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TagException":
        case "com.amazonaws.kms#TagException":
            throw await de_TagExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAliasCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateAliasCommand = de_UpdateAliasCommand;
const de_UpdateAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateCustomKeyStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateCustomKeyStoreCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdateCustomKeyStoreCommand = de_UpdateCustomKeyStoreCommand;
const de_UpdateCustomKeyStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudHsmClusterInvalidConfigurationException":
        case "com.amazonaws.kms#CloudHsmClusterInvalidConfigurationException":
            throw await de_CloudHsmClusterInvalidConfigurationExceptionRes(parsedOutput, context);
        case "CloudHsmClusterNotActiveException":
        case "com.amazonaws.kms#CloudHsmClusterNotActiveException":
            throw await de_CloudHsmClusterNotActiveExceptionRes(parsedOutput, context);
        case "CloudHsmClusterNotFoundException":
        case "com.amazonaws.kms#CloudHsmClusterNotFoundException":
            throw await de_CloudHsmClusterNotFoundExceptionRes(parsedOutput, context);
        case "CloudHsmClusterNotRelatedException":
        case "com.amazonaws.kms#CloudHsmClusterNotRelatedException":
            throw await de_CloudHsmClusterNotRelatedExceptionRes(parsedOutput, context);
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await de_CustomKeyStoreInvalidStateExceptionRes(parsedOutput, context);
        case "CustomKeyStoreNameInUseException":
        case "com.amazonaws.kms#CustomKeyStoreNameInUseException":
            throw await de_CustomKeyStoreNameInUseExceptionRes(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await de_CustomKeyStoreNotFoundExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "XksProxyIncorrectAuthenticationCredentialException":
        case "com.amazonaws.kms#XksProxyIncorrectAuthenticationCredentialException":
            throw await de_XksProxyIncorrectAuthenticationCredentialExceptionRes(parsedOutput, context);
        case "XksProxyInvalidConfigurationException":
        case "com.amazonaws.kms#XksProxyInvalidConfigurationException":
            throw await de_XksProxyInvalidConfigurationExceptionRes(parsedOutput, context);
        case "XksProxyInvalidResponseException":
        case "com.amazonaws.kms#XksProxyInvalidResponseException":
            throw await de_XksProxyInvalidResponseExceptionRes(parsedOutput, context);
        case "XksProxyUriEndpointInUseException":
        case "com.amazonaws.kms#XksProxyUriEndpointInUseException":
            throw await de_XksProxyUriEndpointInUseExceptionRes(parsedOutput, context);
        case "XksProxyUriInUseException":
        case "com.amazonaws.kms#XksProxyUriInUseException":
            throw await de_XksProxyUriInUseExceptionRes(parsedOutput, context);
        case "XksProxyUriUnreachableException":
        case "com.amazonaws.kms#XksProxyUriUnreachableException":
            throw await de_XksProxyUriUnreachableExceptionRes(parsedOutput, context);
        case "XksProxyVpcEndpointServiceInUseException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceInUseException":
            throw await de_XksProxyVpcEndpointServiceInUseExceptionRes(parsedOutput, context);
        case "XksProxyVpcEndpointServiceInvalidConfigurationException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceInvalidConfigurationException":
            throw await de_XksProxyVpcEndpointServiceInvalidConfigurationExceptionRes(parsedOutput, context);
        case "XksProxyVpcEndpointServiceNotFoundException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceNotFoundException":
            throw await de_XksProxyVpcEndpointServiceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateKeyDescriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateKeyDescriptionCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateKeyDescriptionCommand = de_UpdateKeyDescriptionCommand;
const de_UpdateKeyDescriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdatePrimaryRegionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdatePrimaryRegionCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdatePrimaryRegionCommand = de_UpdatePrimaryRegionCommand;
const de_UpdatePrimaryRegionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_VerifyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_VerifyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_VerifyCommand = de_VerifyCommand;
const de_VerifyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await de_DependencyTimeoutExceptionRes(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidSignatureException":
        case "com.amazonaws.kms#KMSInvalidSignatureException":
            throw await de_KMSInvalidSignatureExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_VerifyMacCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_VerifyMacCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_VerifyMacCommand = de_VerifyMacCommand;
const de_VerifyMacCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await de_DisabledExceptionRes(parsedOutput, context);
        case "DryRunOperationException":
        case "com.amazonaws.kms#DryRunOperationException":
            throw await de_DryRunOperationExceptionRes(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await de_InvalidGrantTokenExceptionRes(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await de_InvalidKeyUsageExceptionRes(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await de_KMSInternalExceptionRes(parsedOutput, context);
        case "KMSInvalidMacException":
        case "com.amazonaws.kms#KMSInvalidMacException":
            throw await de_KMSInvalidMacExceptionRes(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await de_KMSInvalidStateExceptionRes(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await de_KeyUnavailableExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.AlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CloudHsmClusterInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CloudHsmClusterInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CloudHsmClusterInvalidConfigurationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CloudHsmClusterInvalidConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CloudHsmClusterNotActiveExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CloudHsmClusterNotActiveException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CloudHsmClusterNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CloudHsmClusterNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CloudHsmClusterNotRelatedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CloudHsmClusterNotRelatedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CustomKeyStoreHasCMKsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CustomKeyStoreHasCMKsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CustomKeyStoreInvalidStateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CustomKeyStoreInvalidStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CustomKeyStoreNameInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CustomKeyStoreNameInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CustomKeyStoreNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CustomKeyStoreNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DependencyTimeoutExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DependencyTimeoutException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DisabledExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DisabledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DryRunOperationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DryRunOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ExpiredImportTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ExpiredImportTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IncorrectKeyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.IncorrectKeyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IncorrectKeyMaterialExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.IncorrectKeyMaterialException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IncorrectTrustAnchorExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.IncorrectTrustAnchorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidAliasNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidAliasNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidArnExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidCiphertextExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidCiphertextException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidGrantIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidGrantIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidGrantTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidGrantTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidImportTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidImportTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidKeyUsageExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidKeyUsageException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidMarkerExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidMarkerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_KeyUnavailableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.KeyUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_KMSInternalExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.KMSInternalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_KMSInvalidMacExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.KMSInvalidMacException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_KMSInvalidSignatureExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.KMSInvalidSignatureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_KMSInvalidStateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.KMSInvalidStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MalformedPolicyDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TagExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TagException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnsupportedOperationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UnsupportedOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksKeyAlreadyInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksKeyAlreadyInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksKeyInvalidConfigurationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksKeyInvalidConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksKeyNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksKeyNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksProxyIncorrectAuthenticationCredentialExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksProxyIncorrectAuthenticationCredentialException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksProxyInvalidConfigurationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksProxyInvalidConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksProxyInvalidResponseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksProxyInvalidResponseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksProxyUriEndpointInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksProxyUriEndpointInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksProxyUriInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksProxyUriInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksProxyUriUnreachableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksProxyUriUnreachableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksProxyVpcEndpointServiceInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksProxyVpcEndpointServiceInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksProxyVpcEndpointServiceInvalidConfigurationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksProxyVpcEndpointServiceInvalidConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_XksProxyVpcEndpointServiceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.XksProxyVpcEndpointServiceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_DecryptRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        CiphertextBlob: context.base64Encoder,
        DryRun: [],
        EncryptionAlgorithm: [],
        EncryptionContext: smithy_client_1._json,
        GrantTokens: smithy_client_1._json,
        KeyId: [],
        Recipient: (_) => se_RecipientInfo(_, context),
    });
};
const se_EncryptRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DryRun: [],
        EncryptionAlgorithm: [],
        EncryptionContext: smithy_client_1._json,
        GrantTokens: smithy_client_1._json,
        KeyId: [],
        Plaintext: context.base64Encoder,
    });
};
const se_GenerateDataKeyPairRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DryRun: [],
        EncryptionContext: smithy_client_1._json,
        GrantTokens: smithy_client_1._json,
        KeyId: [],
        KeyPairSpec: [],
        Recipient: (_) => se_RecipientInfo(_, context),
    });
};
const se_GenerateDataKeyRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DryRun: [],
        EncryptionContext: smithy_client_1._json,
        GrantTokens: smithy_client_1._json,
        KeyId: [],
        KeySpec: [],
        NumberOfBytes: [],
        Recipient: (_) => se_RecipientInfo(_, context),
    });
};
const se_GenerateMacRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DryRun: [],
        GrantTokens: smithy_client_1._json,
        KeyId: [],
        MacAlgorithm: [],
        Message: context.base64Encoder,
    });
};
const se_GenerateRandomRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        CustomKeyStoreId: [],
        NumberOfBytes: [],
        Recipient: (_) => se_RecipientInfo(_, context),
    });
};
const se_ImportKeyMaterialRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        EncryptedKeyMaterial: context.base64Encoder,
        ExpirationModel: [],
        ImportToken: context.base64Encoder,
        KeyId: [],
        ValidTo: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_RecipientInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AttestationDocument: context.base64Encoder,
        KeyEncryptionAlgorithm: [],
    });
};
const se_ReEncryptRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        CiphertextBlob: context.base64Encoder,
        DestinationEncryptionAlgorithm: [],
        DestinationEncryptionContext: smithy_client_1._json,
        DestinationKeyId: [],
        DryRun: [],
        GrantTokens: smithy_client_1._json,
        SourceEncryptionAlgorithm: [],
        SourceEncryptionContext: smithy_client_1._json,
        SourceKeyId: [],
    });
};
const se_SignRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DryRun: [],
        GrantTokens: smithy_client_1._json,
        KeyId: [],
        Message: context.base64Encoder,
        MessageType: [],
        SigningAlgorithm: [],
    });
};
const se_VerifyMacRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DryRun: [],
        GrantTokens: smithy_client_1._json,
        KeyId: [],
        Mac: context.base64Encoder,
        MacAlgorithm: [],
        Message: context.base64Encoder,
    });
};
const se_VerifyRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        DryRun: [],
        GrantTokens: smithy_client_1._json,
        KeyId: [],
        Message: context.base64Encoder,
        MessageType: [],
        Signature: context.base64Encoder,
        SigningAlgorithm: [],
    });
};
const de_AliasList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AliasListEntry(entry, context);
    });
    return retVal;
};
const de_AliasListEntry = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AliasArn: smithy_client_1.expectString,
        AliasName: smithy_client_1.expectString,
        CreationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        LastUpdatedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        TargetKeyId: smithy_client_1.expectString,
    });
};
const de_CreateKeyResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        KeyMetadata: (_) => de_KeyMetadata(_, context),
    });
};
const de_CustomKeyStoresList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CustomKeyStoresListEntry(entry, context);
    });
    return retVal;
};
const de_CustomKeyStoresListEntry = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CloudHsmClusterId: smithy_client_1.expectString,
        ConnectionErrorCode: smithy_client_1.expectString,
        ConnectionState: smithy_client_1.expectString,
        CreationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        CustomKeyStoreId: smithy_client_1.expectString,
        CustomKeyStoreName: smithy_client_1.expectString,
        CustomKeyStoreType: smithy_client_1.expectString,
        TrustAnchorCertificate: smithy_client_1.expectString,
        XksProxyConfiguration: smithy_client_1._json,
    });
};
const de_DecryptResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CiphertextForRecipient: context.base64Decoder,
        EncryptionAlgorithm: smithy_client_1.expectString,
        KeyId: smithy_client_1.expectString,
        Plaintext: context.base64Decoder,
    });
};
const de_DescribeCustomKeyStoresResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CustomKeyStores: (_) => de_CustomKeyStoresList(_, context),
        NextMarker: smithy_client_1.expectString,
        Truncated: smithy_client_1.expectBoolean,
    });
};
const de_DescribeKeyResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        KeyMetadata: (_) => de_KeyMetadata(_, context),
    });
};
const de_EncryptResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CiphertextBlob: context.base64Decoder,
        EncryptionAlgorithm: smithy_client_1.expectString,
        KeyId: smithy_client_1.expectString,
    });
};
const de_GenerateDataKeyPairResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CiphertextForRecipient: context.base64Decoder,
        KeyId: smithy_client_1.expectString,
        KeyPairSpec: smithy_client_1.expectString,
        PrivateKeyCiphertextBlob: context.base64Decoder,
        PrivateKeyPlaintext: context.base64Decoder,
        PublicKey: context.base64Decoder,
    });
};
const de_GenerateDataKeyPairWithoutPlaintextResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        KeyId: smithy_client_1.expectString,
        KeyPairSpec: smithy_client_1.expectString,
        PrivateKeyCiphertextBlob: context.base64Decoder,
        PublicKey: context.base64Decoder,
    });
};
const de_GenerateDataKeyResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CiphertextBlob: context.base64Decoder,
        CiphertextForRecipient: context.base64Decoder,
        KeyId: smithy_client_1.expectString,
        Plaintext: context.base64Decoder,
    });
};
const de_GenerateDataKeyWithoutPlaintextResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CiphertextBlob: context.base64Decoder,
        KeyId: smithy_client_1.expectString,
    });
};
const de_GenerateMacResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        KeyId: smithy_client_1.expectString,
        Mac: context.base64Decoder,
        MacAlgorithm: smithy_client_1.expectString,
    });
};
const de_GenerateRandomResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CiphertextForRecipient: context.base64Decoder,
        Plaintext: context.base64Decoder,
    });
};
const de_GetParametersForImportResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ImportToken: context.base64Decoder,
        KeyId: smithy_client_1.expectString,
        ParametersValidTo: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        PublicKey: context.base64Decoder,
    });
};
const de_GetPublicKeyResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CustomerMasterKeySpec: smithy_client_1.expectString,
        EncryptionAlgorithms: smithy_client_1._json,
        KeyId: smithy_client_1.expectString,
        KeySpec: smithy_client_1.expectString,
        KeyUsage: smithy_client_1.expectString,
        PublicKey: context.base64Decoder,
        SigningAlgorithms: smithy_client_1._json,
    });
};
const de_GrantList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GrantListEntry(entry, context);
    });
    return retVal;
};
const de_GrantListEntry = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Constraints: smithy_client_1._json,
        CreationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        GrantId: smithy_client_1.expectString,
        GranteePrincipal: smithy_client_1.expectString,
        IssuingAccount: smithy_client_1.expectString,
        KeyId: smithy_client_1.expectString,
        Name: smithy_client_1.expectString,
        Operations: smithy_client_1._json,
        RetiringPrincipal: smithy_client_1.expectString,
    });
};
const de_KeyMetadata = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AWSAccountId: smithy_client_1.expectString,
        Arn: smithy_client_1.expectString,
        CloudHsmClusterId: smithy_client_1.expectString,
        CreationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        CustomKeyStoreId: smithy_client_1.expectString,
        CustomerMasterKeySpec: smithy_client_1.expectString,
        DeletionDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        Description: smithy_client_1.expectString,
        Enabled: smithy_client_1.expectBoolean,
        EncryptionAlgorithms: smithy_client_1._json,
        ExpirationModel: smithy_client_1.expectString,
        KeyId: smithy_client_1.expectString,
        KeyManager: smithy_client_1.expectString,
        KeySpec: smithy_client_1.expectString,
        KeyState: smithy_client_1.expectString,
        KeyUsage: smithy_client_1.expectString,
        MacAlgorithms: smithy_client_1._json,
        MultiRegion: smithy_client_1.expectBoolean,
        MultiRegionConfiguration: smithy_client_1._json,
        Origin: smithy_client_1.expectString,
        PendingDeletionWindowInDays: smithy_client_1.expectInt32,
        SigningAlgorithms: smithy_client_1._json,
        ValidTo: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        XksKeyConfiguration: smithy_client_1._json,
    });
};
const de_ListAliasesResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Aliases: (_) => de_AliasList(_, context),
        NextMarker: smithy_client_1.expectString,
        Truncated: smithy_client_1.expectBoolean,
    });
};
const de_ListGrantsResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Grants: (_) => de_GrantList(_, context),
        NextMarker: smithy_client_1.expectString,
        Truncated: smithy_client_1.expectBoolean,
    });
};
const de_ReEncryptResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CiphertextBlob: context.base64Decoder,
        DestinationEncryptionAlgorithm: smithy_client_1.expectString,
        KeyId: smithy_client_1.expectString,
        SourceEncryptionAlgorithm: smithy_client_1.expectString,
        SourceKeyId: smithy_client_1.expectString,
    });
};
const de_ReplicateKeyResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ReplicaKeyMetadata: (_) => de_KeyMetadata(_, context),
        ReplicaPolicy: smithy_client_1.expectString,
        ReplicaTags: smithy_client_1._json,
    });
};
const de_ScheduleKeyDeletionResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        DeletionDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        KeyId: smithy_client_1.expectString,
        KeyState: smithy_client_1.expectString,
        PendingWindowInDays: smithy_client_1.expectInt32,
    });
};
const de_SignResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        KeyId: smithy_client_1.expectString,
        Signature: context.base64Decoder,
        SigningAlgorithm: smithy_client_1.expectString,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = (0, smithy_client_1.withBaseException)(KMSServiceException_1.KMSServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `TrentService.${operation}`,
    };
}
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
